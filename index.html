<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Tetris — Footer Fixed & Bigger Field</title>
<style>
:root{--bg:#121212;--panel:#1e1e1e;--muted:#888;}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Segoe UI,Meiryo,Arial;touch-action:none;-webkit-user-select:none;user-select:none}
header{
  height:64px;
  background:var(--panel);
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:6px 10px;
  border-bottom:1px solid #2b2b2b;
  gap:8px;
  flex-wrap:wrap;
  z-index:40;
  position:relative;
}
.stat-group{display:flex;gap:10px;align-items:center}
.stat-item{font-size:12px;text-align:center;min-width:48px}
.stat-label{font-size:10px;color:var(--muted);letter-spacing:1px}
.stat-val{font-family:monospace;font-weight:700;font-size:14px;color:#eee}
.controls-inline{display:flex;align-items:center;gap:8px;flex-wrap:wrap}

/* toggles */
.toggle{
  background:#333;padding:6px 8px;border-radius:8px;cursor:pointer;font-size:12px;user-select:none;min-width:40px;text-align:center;
}
.toggle.on{background:#0b7a5f;color:#fff}

/* slider */
.slider{width:120px}

/* Game area fills remaining height (we will compute exact canvas size in JS) */
#game-area{position:relative;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#000 0%, #060606 100%);box-sizing:border-box;padding:6px 6px 6px 6px;overflow:hidden}

/* canvas sized by script; allow CSS max for safety */
canvas{background:rgba(20,20,20,0.95);box-shadow:0 0 30px rgba(0,0,0,0.6);border:2px solid #333;display:block;max-width:100%;max-height:100%}
#next-area{position:absolute;top:12px;right:12px;background:rgba(30,30,30,0.72);padding:6px;border-radius:8px;border:1px solid #3a3a3a;pointer-events:none}
#overlay{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;background:rgba(0,0,0,0.78);z-index:45}
#overlay h1{font-size:32px;color:#FF6B6B;margin:0 0 8px 0}
#btn-action{padding:12px 28px;border-radius:40px;border:none;background:linear-gradient(135deg,#2196F3,#2979FF);color:#fff;font-size:16px;cursor:pointer}
#btn-action:active{transform:scale(.98)}

/* FOOTER — fixed at bottom, compact */
#footer{
  position:fixed;
  left:0;
  right:0;
  bottom:env(safe-area-inset-bottom,0); /* respect notch safe area */
  height:96px; /* slightly compact */
  background:var(--panel);
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:8px 10px;
  border-top:1px solid #2b2b2b;
  box-sizing:border-box;
  gap:8px;
  z-index:50;
}

/* smaller buttons */
.btn{
  width:56px; height:56px; border-radius:50%; background:#333; display:flex; align-items:center; justify-content:center;
  font-size:18px; color:#e6e6e6; box-shadow:0 6px 0 #111; user-select:none;
}
.btn:active{transform:translateY(6px);box-shadow:inset 0 2px 5px rgba(0,0,0,.4);background:#444}
.btn-blue{background:#1976D2}
.btn-red{background:#D32F2F}

.label-small{font-size:12px;color:var(--muted)}

/* Responsive for small screens */
@media (max-width:520px){
  header{height:auto;padding:6px}
  .stat-item{font-size:11px;min-width:44px}
  .slider{width:92px}
  #footer{height:88px;padding:6px}
  .btn{width:48px;height:48px;font-size:16px}
  .toggle{font-size:11px;padding:4px 6px;min-width:36px}
  #next-area{right:8px;top:8px}
}
</style>
</head>
<body>

<header id="header">
  <div class="stat-group">
    <div class="stat-item"><div class="stat-label">SCORE</div><div id="score" class="stat-val">0</div></div>
    <div class="stat-item"><div class="stat-label">LINES</div><div id="lines" class="stat-val">0</div></div>
    <div class="stat-item"><div class="stat-label">LEVEL</div><div id="level" class="stat-val">1</div></div>
  </div>

  <div class="controls-inline">
    <div style="display:flex;align-items:center;gap:6px">
      <span class="label-small">BGM</span>
      <div id="bgm-toggle" class="toggle on">ON</div>
    </div>

    <div style="display:flex;align-items:center;gap:6px">
      <span class="label-small">SFX</span>
      <div id="sfx-toggle" class="toggle on">ON</div>
    </div>

    <div style="display:flex;align-items:center;gap:6px">
      <span class="label-small">VOL</span>
      <input id="bgm-volume" class="slider" type="range" min="0" max="0.12" step="0.005" value="0.04">
    </div>

    <div style="display:flex;align-items:center;gap:6px">
      <div id="pause-btn" class="toggle">PAUSE</div>
    </div>
  </div>
</header>

<!-- Main game area: we will compute available height in JS (window.innerHeight - header - footer) -->
<div id="game-area">
  <canvas id="tetris"></canvas>
  <div id="next-area">
    <div style="font-size:12px;color:#bbb;margin-bottom:6px">NEXT</div>
    <canvas id="next-canvas" width="60" height="60"></canvas>
  </div>

  <div id="overlay">
    <h1 id="overlay-title">TETRIS</h1>
    <p id="overlay-msg">TAP PLAY TO START</p>
    <button id="btn-action">PLAY</button>
  </div>
</div>

<!-- Footer fixed at bottom -->
<div id="footer">
  <div style="display:flex;gap:8px;align-items:center">
    <div class="btn" id="btn-left">←</div>
    <div class="btn" id="btn-right">→</div>
  </div>

  <div style="display:flex;gap:8px;align-items:center">
    <div class="btn btn-blue" id="btn-drop">⇓</div>
    <div class="btn btn-red" id="btn-rotate">↻</div>
  </div>
</div>

<script>
/* ========= game & audio (keeps previous chiptune Troika) ========= */
const PIECES = [null,
  [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  [[2,0,0],[2,2,2],[0,0,0]],
  [[0,0,3],[3,3,3],[0,0,0]],
  [[4,4],[4,4]],
  [[0,5,5],[5,5,0],[0,0,0]],
  [[0,6,0],[6,6,6],[0,0,0]],
  [[7,7,0],[0,7,7],[0,0,0]]
];
const COLORS = [null,'#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000'];

const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const nCanvas = document.getElementById('next-canvas');
const nCtx = nCanvas.getContext('2d');
const header = document.getElementById('header');
const footer = document.getElementById('footer');
const gameArea = document.getElementById('game-area');

const COLS = 10, ROWS = 20;
let blockSize = 20;

let board = [];
let player = { pos: {x:0,y:0}, matrix:null, score:0 };
let nextPieceType = 1;
let dropCounter = 0, dropInterval = 1000, lastTime = 0;
let isGameOver=false, isPaused=true, animationId=null;
let level = 1, linesTotal = 0;

/* AUDIO (chip Troika) */
let audioCtx=null, bgmInterval=null, bgmIndex=0;
const TROIKA_MELODY = [659.25,587.33,523.25,523.25,587.33,659.25,783.99,659.25,587.33,523.25,440.00,392.00];
let masterGain=null, masterSfxGain=null;
let bgmOn=true, sfxOn=true;

function initAudioIfNeeded(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain(); masterGain.gain.setValueAtTime(parseFloat(document.getElementById('bgm-volume').value || 0.04), audioCtx.currentTime);
  masterGain.connect(audioCtx.destination);
  masterSfxGain = audioCtx.createGain(); masterSfxGain.gain.setValueAtTime(0.9, audioCtx.currentTime); masterSfxGain.connect(audioCtx.destination);
}

function playChipNote(freq, dur = 0.22, vel = 0.05){
  if (!audioCtx || !bgmOn) return;
  const now = audioCtx.currentTime;
  const o1 = audioCtx.createOscillator(); o1.type = 'square'; o1.frequency.setValueAtTime(freq, now);
  const o2 = audioCtx.createOscillator(); o2.type = 'square'; o2.frequency.setValueAtTime(freq * 1.003, now);
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(vel, now+0.004); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
  o1.connect(g); o2.connect(g); g.connect(masterGain);
  o1.start(now); o2.start(now); o1.stop(now+dur); o2.stop(now+dur);
}
function playChipAccent(freq, delay = 0.08){
  if (!audioCtx || !bgmOn) return;
  const now = audioCtx.currentTime + delay;
  const o = audioCtx.createOscillator(); o.type = 'square'; o.frequency.setValueAtTime(freq, now);
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0, now); g.gain.linearRampToValueAtTime(0.03, now+0.002); g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
  o.connect(g); g.connect(masterGain); o.start(now); o.stop(now+0.12);
}
function playBGM(){
  if (!audioCtx) return;
  stopBGM();
  bgmIndex = 0;
  const baseInterval = Math.max(180, 360 - (level - 1) * 12);
  bgmInterval = setInterval(()=> {
    if (isPaused || isGameOver || !bgmOn) return;
    const note = TROIKA_MELODY[bgmIndex % TROIKA_MELODY.length];
    playChipNote(note, 0.22, 0.05 + Math.min(0.05, level * 0.004));
    setTimeout(()=> { if (audioCtx && !isPaused && !isGameOver && bgmOn) playChipAccent(note * 1.5, 0); }, 80);
    bgmIndex++;
  }, baseInterval);
}
function stopBGM(){ if (bgmInterval){ clearInterval(bgmInterval); bgmInterval = null; } }
function playSfx(type){
  if (!audioCtx || !sfxOn) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.connect(g); g.connect(masterSfxGain);
  switch(type){
    case 'move': osc.type='square'; osc.frequency.setValueAtTime(220, now); g.gain.setValueAtTime(0.04, now); g.gain.exponentialRampToValueAtTime(0.0001, now+0.06); osc.start(now); osc.stop(now+0.06); break;
    case 'rotate': osc.type='sine'; osc.frequency.setValueAtTime(420, now); g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.0001, now+0.1); osc.start(now); osc.stop(now+0.1); break;
    case 'drop': osc.type='square'; osc.frequency.setValueAtTime(110, now); g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.0001, now+0.08); osc.start(now); osc.stop(now+0.08); break;
    case 'clear': (()=>{
      const o1 = audioCtx.createOscillator(), g1 = audioCtx.createGain(); o1.type='square'; o1.frequency.setValueAtTime(523.25, now); g1.gain.setValueAtTime(0.09, now); o1.connect(g1); g1.connect(masterSfxGain); o1.start(now); o1.stop(now+0.18);
      const o2 = audioCtx.createOscillator(), g2 = audioCtx.createGain(); o2.type='sine'; o2.frequency.setValueAtTime(659.25, now+0.05); g2.gain.setValueAtTime(0.07, now+0.05); o2.connect(g2); g2.connect(masterSfxGain); o2.start(now+0.05); o2.stop(now+0.22);
    })(); break;
    case 'gameover': osc.type='sawtooth'; osc.frequency.setValueAtTime(150, now); g.gain.setValueAtTime(0.12, now); g.gain.linearRampToValueAtTime(0.0001, now+0.9); osc.start(now); osc.stop(now+0.9); break;
  }
}

/* ---------- core game ---------- */
function createPiece(typeId){ if(!typeId) typeId=(Math.random()*7|0)+1; return JSON.parse(JSON.stringify(PIECES[typeId])); }
function rotate(matrix, dir){ for(let y=0;y<matrix.length;++y) for(let x=0;x<y;++x) [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]]; if(dir>0) matrix.forEach(row=>row.reverse()); else matrix.reverse(); }
function collide(arena, player){ const [m,o]=[player.matrix,player.pos]; for(let y=0;y<m.length;++y) for(let x=0;x<m[y].length;++x) if(m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0) return true; return false; }
function merge(arena, player){ player.matrix.forEach((row,y)=> row.forEach((v,x)=> { if(v!==0) arena[y+player.pos.y][x+player.pos.x] = v; })); }

function arenaSweep(){
  let rowCount=0;
  outer: for(let y=board.length-1;y>0;--y){
    for(let x=0;x<board[y].length;++x) if(board[y][x]===0) continue outer;
    const row = board.splice(y,1)[0].fill(0); board.unshift(row); ++y; rowCount++;
  }
  if(rowCount>0){
    linesTotal += rowCount;
    player.score += rowCount * 100 * rowCount;
    level = Math.floor(linesTotal/10) + 1;
    document.getElementById('level').innerText = level;
    dropInterval = Math.max(80, 1000 - (level - 1) * 90);
    document.getElementById('score').innerText = player.score;
    document.getElementById('lines').innerText = linesTotal;
    playSfx('clear');
  }
}

function playerReset(){
  player.matrix = createPiece(nextPieceType);
  nextPieceType = (Math.random()*7|0)+1;
  drawNext();
  player.pos.y = 0;
  player.pos.x = (COLS/2|0) - (player.matrix[0].length/2|0);
  const rot = Math.random()*4|0; for(let i=0;i<rot;i++) rotate(player.matrix,1);
  if(collide(board, player)){
    isGameOver=true; isPaused=true; stopBGM(); playSfx('gameover');
    document.getElementById('overlay-title').innerText='GAME OVER';
    document.getElementById('overlay-msg').innerText='SCORE: ' + player.score;
    document.getElementById('btn-action').innerText='RETRY';
    document.getElementById('overlay').style.display='flex';
  }
}

function playerDrop(){ player.pos.y++; if(collide(board, player)){ player.pos.y--; merge(board, player); playSfx('drop'); arenaSweep(); playerReset(); return; } dropCounter = 0; }
function playerMove(dir){ player.pos.x += dir; if(collide(board, player)) player.pos.x -= dir; else playSfx('move'); }
function playerRotate(dir){ const pos = player.pos.x; let offset=1; rotate(player.matrix, dir); while(collide(board, player)){ player.pos.x += offset; offset = -(offset + (offset>0?1:-1)); if(offset>2){ rotate(player.matrix,-dir); player.pos.x = pos; return; } } playSfx('rotate'); }

/* ---------- drawing ---------- */
function drawMatrix(matrix, offset, ctxLocal){
  matrix.forEach((row,y)=> row.forEach((value,x)=> {
    if(value!==0){
      ctxLocal.fillStyle = COLORS[value];
      ctxLocal.fillRect(x + offset.x, y + offset.y, 1, 1);
      ctxLocal.strokeStyle = 'rgba(0,0,0,0.22)';
      ctxLocal.lineWidth = 0.04;
      ctxLocal.strokeRect(x + offset.x, y + offset.y, 1, 1);
      ctxLocal.fillStyle = 'rgba(255,255,255,0.06)';
      ctxLocal.fillRect(x + offset.x + 0.06, y + offset.y + 0.06, 0.4, 0.18);
    }
  }));
}

function drawGhost(){
  let ghostY = player.pos.y;
  while(!collide(board, {matrix:player.matrix, pos:{x:player.pos.x, y:ghostY+1}})) ghostY++;
  ctx.globalAlpha = 0.25; drawMatrix(player.matrix, {x:player.pos.x, y:ghostY}, ctx); ctx.globalAlpha = 1.0;
}

function draw(){
  // clear device pixels
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  ctx.setTransform(dpr * blockSize, 0, 0, dpr * blockSize, 0, 0);
  drawMatrix(board, {x:0,y:0}, ctx);
  if(player.matrix){ drawGhost(); drawMatrix(player.matrix, player.pos, ctx); }
}

function drawNext(){
  nCtx.clearRect(0,0,nCanvas.width,nCanvas.height);
  const mat = PIECES[nextPieceType];
  const scale = 15;
  const offsetX = (nCanvas.width/scale - mat[0].length)/2;
  const offsetY = (nCanvas.height/scale - mat.length)/2;
  nCtx.save(); nCtx.scale(scale, scale);
  mat.forEach((row,y)=> row.forEach((v,x)=> { if(v!==0){ nCtx.fillStyle = COLORS[v]; nCtx.fillRect(x+offsetX, y+offsetY, 1,1); nCtx.strokeStyle='rgba(0,0,0,0.22)'; nCtx.lineWidth=0.06; nCtx.strokeRect(x+offsetX, y+offsetY, 1,1); } }));
  nCtx.restore();
}

/* ---------- loop & input ---------- */
let inputState = {left:false,right:false,down:false,rotate:false};
let inputTimers = {left:0,right:0,rotate:0};

function update(time=0){
  if(isPaused) return;
  const deltaTime = time - lastTime; lastTime = time;
  dropCounter += deltaTime;
  const interval = inputState.down ? 50 : dropInterval;
  if(dropCounter > interval) playerDrop();
  const now = Date.now();
  if(inputState.left){ if(now - inputTimers.left > 120){ playerMove(-1); inputTimers.left = now; } }
  if(inputState.right){ if(now - inputTimers.right > 120){ playerMove(1); inputTimers.right = now; } }
  if(inputState.rotate){ if(now - inputTimers.rotate > 250){ playerRotate(1); inputTimers.rotate = now; } }
  draw();
  animationId = requestAnimationFrame(update);
}

/* ---------- controls ---------- */
function setupControls(){
  const bindBtn = (id,key,action) => {
    const el = document.getElementById(id);
    const start = e => { e && e.preventDefault(); if(isGameOver || isPaused) return; el.classList.add('active'); inputState[key]=true; inputTimers[key]=Date.now(); if(key!=='down') action(); };
    const end = e => { e && e.preventDefault(); el.classList.remove('active'); inputState[key]=false; };
    el.addEventListener('touchstart', start, {passive:false}); el.addEventListener('mousedown', start);
    el.addEventListener('touchend', end); el.addEventListener('mouseup', end); el.addEventListener('mouseleave', end);
  };
  bindBtn('btn-left','left', ()=>playerMove(-1));
  bindBtn('btn-right','right', ()=>playerMove(1));
  bindBtn('btn-rotate','rotate', ()=>playerRotate(1));
  const btnDrop = document.getElementById('btn-drop');
  const dropStart = e => { e && e.preventDefault(); if(isGameOver || isPaused) return; btnDrop.classList.add('active'); inputState.down = true; };
  const dropEnd = e => { e && e.preventDefault(); btnDrop.classList.remove('active'); inputState.down = false; };
  btnDrop.addEventListener('touchstart', dropStart, {passive:false}); btnDrop.addEventListener('mousedown', dropStart);
  btnDrop.addEventListener('touchend', dropEnd); btnDrop.addEventListener('mouseup', dropEnd); btnDrop.addEventListener('mouseleave', dropEnd);

  canvas.addEventListener('touchstart', (e)=>{ if(isPaused) startGame(); }, {passive:false});
  canvas.addEventListener('mousedown', ()=>{ if(isPaused) startGame(); });
}

/* ---------- lifecycle & UI ---------- */
function startGame(){
  initAudioIfNeeded();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  if(bgmOn) playBGM();
  document.getElementById('overlay').style.display='none';
  board = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));
  player.score = 0; linesTotal = 0; level = 1;
  document.getElementById('score').innerText = 0;
  document.getElementById('lines').innerText = 0;
  document.getElementById('level').innerText = 1;
  dropInterval = 1000;
  isGameOver=false; isPaused=false;
  nextPieceType = (Math.random()*7|0)+1;
  playerReset();
  lastTime = performance.now();
  update();
}

function pauseGame(){
  if(isPaused) return;
  isPaused = true; cancelAnimationFrame(animationId); stopBGM();
  document.getElementById('overlay-title').innerText='PAUSED';
  document.getElementById('overlay-msg').innerText='TAP RESUME';
  document.getElementById('btn-action').innerText='RESUME';
  document.getElementById('overlay').style.display='flex';
}

function resumeGame(){
  if(!isPaused && !isGameOver) return;
  isPaused = false; document.getElementById('overlay').style.display='none'; lastTime = performance.now();
  if(bgmOn) playBGM(); update();
}

/* UI wiring */
document.getElementById('btn-action').addEventListener('click', ()=>{
  if(isGameOver){ /* retry */ }
  if(isPaused && !isGameOver && document.getElementById('btn-action').innerText === 'RESUME'){ resumeGame(); return; }
  startGame();
});
document.getElementById('pause-btn').addEventListener('click', ()=>{
  if(!audioCtx) initAudioIfNeeded();
  if(!isPaused) pauseGame(); else resumeGame();
  document.getElementById('pause-btn').classList.toggle('on', isPaused && !isGameOver);
  document.getElementById('pause-btn').innerText = isPaused ? 'RESUME' : 'PAUSE';
});
document.getElementById('bgm-toggle').addEventListener('click', ()=>{
  bgmOn = !bgmOn; const el = document.getElementById('bgm-toggle'); el.classList.toggle('on', bgmOn); el.innerText = bgmOn ? 'ON':'OFF';
  if(bgmOn){ if(!audioCtx) initAudioIfNeeded(); playBGM(); } else stopBGM();
});
document.getElementById('sfx-toggle').addEventListener('click', ()=>{
  sfxOn = !sfxOn; const el = document.getElementById('sfx-toggle'); el.classList.toggle('on', sfxOn); el.innerText = sfxOn ? 'ON':'OFF';
});
document.getElementById('bgm-volume').addEventListener('input', (e)=>{
  const v = parseFloat(e.target.value);
  if(masterGain && audioCtx) masterGain.gain.setValueAtTime(v, audioCtx.currentTime);
});

/* ======= RESIZE: compute available height excluding header/footer ======= */
function resize(){
  // header and footer heights (include computed borders/paddings)
  const headerRect = header.getBoundingClientRect();
  const footerRect = footer.getBoundingClientRect();

  // available area between header bottom and footer top
  const availW = window.innerWidth - 12; // small margin
  const availH = Math.max(160, window.innerHeight - headerRect.height - footerRect.height - 12);

  // compute largest integer block size that fits both dimensions
  const maxBlockW = availW / COLS;
  const maxBlockH = availH / ROWS;
  const blockCss = Math.floor(Math.max(8, Math.min(maxBlockW, maxBlockH)));

  const cssWidth = blockCss * COLS;
  const cssHeight = blockCss * ROWS;

  // center the canvas horizontally and vertically within game-area
  canvas.style.width = cssWidth + 'px';
  canvas.style.height = cssHeight + 'px';

  // set backing buffer size using devicePixelRatio
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(cssWidth * dpr);
  canvas.height = Math.floor(cssHeight * dpr);

  blockSize = blockCss;

  // set transform for drawing (1 unit == 1 block)
  ctx.setTransform(dpr * blockSize, 0, 0, dpr * blockSize, 0, 0);

  // update next canvas scale
  const nDpr = Math.max(1, window.devicePixelRatio || 1);
  nCanvas.width = Math.floor(nCanvas.clientWidth * nDpr);
  nCanvas.height = Math.floor(nCanvas.clientHeight * nDpr);
  nCtx.setTransform(nDpr,0,0,nDpr,0,0);

  // redraw
  draw();
  drawNext();
}

// observe resize and orientation changes
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', ()=> setTimeout(resize, 120));

/* init */
setupControls();
resize();
</script>
</body>
</html>
