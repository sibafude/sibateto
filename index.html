<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Tetris Perfect — BGM & Controls</title>
<style>
    :root{--bg:#121212;--panel:#1e1e1e;--muted:#888;}
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Segoe UI,Meiryo,Arial;touch-action:none;-webkit-user-select:none;user-select:none;}
    header{height:64px;background:var(--panel);display:flex;align-items:center;justify-content:space-between;padding:0 16px;border-bottom:1px solid #2b2b2b;box-sizing:border-box;}
    .stat-group{display:flex;gap:18px;align-items:center}
    .stat-item{font-size:13px;text-align:center}
    .stat-label{font-size:11px;color:var(--muted);letter-spacing:1px}
    .stat-val{font-family:monospace;font-weight:700;font-size:16px;color:#eee}
    .controls-inline{display:flex;align-items:center;gap:10px}
    .toggle{background:#333;padding:6px 8px;border-radius:8px;cursor:pointer;font-size:13px;user-select:none}
    .toggle.on{background:#0b7a5f;color:#fff}
    .small{font-size:12px;color:var(--muted);margin-right:6px}
    .slider{width:120px}
    #game-area{flex:1;display:flex;align-items:center;justify-content:center;position:relative;background:linear-gradient(180deg,#000 0%, #060606 100%);}
    canvas{background:rgba(20,20,20,0.95);box-shadow:0 0 30px rgba(0,0,0,0.6);border:2px solid #333;display:block;}
    #next-area{position:absolute;top:16px;right:16px;background:rgba(30,30,30,0.7);padding:8px;border-radius:8px;border:1px solid #3a3a3a}
    #overlay{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;background:rgba(0,0,0,0.78);z-index:50}
    #overlay h1{font-size:36px;color:#FF6B6B;margin:0 0 8px 0}
    #overlay p{color:#ccc;margin:0 0 18px 0}
    #btn-action{padding:12px 36px;border-radius:40px;border:none;background:linear-gradient(135deg,#2196F3,#2979FF);color:#fff;font-size:16px;cursor:pointer}
    #btn-action:active{transform:scale(.98)}
    #footer{height:160px;background:var(--panel);display:flex;align-items:center;justify-content:space-between;padding:0 22px;border-top:1px solid #2b2b2b;box-sizing:border-box}
    .btn{width:72px;height:72px;border-radius:50%;background:#333;display:flex;align-items:center;justify-content:center;font-size:22px;color:#e6e6e6;box-shadow:0 6px 0 #111;user-select:none}
    .btn:active{transform:translateY(6px);box-shadow:inset 0 2px 5px rgba(0,0,0,.4);background:#444}
    .btn-blue{background:#1976D2}
    .btn-red{background:#D32F2F}
    .ui-row{display:flex;align-items:center;gap:10px}
    .label-small{font-size:12px;color:var(--muted)}
    .badge{font-size:12px;color:#fff;background:#2a2a2a;padding:6px 10px;border-radius:10px}
    input[type="range"]{accent-color:#2196F3}
    @media (max-width:520px){ .slider{width:92px} }
</style>
</head>
<body>

<header>
    <div class="stat-group">
        <div class="stat-item">
            <div class="stat-label">SCORE</div>
            <div id="score" class="stat-val">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">LINES</div>
            <div id="lines" class="stat-val">0</div>
        </div>
    </div>

    <div class="controls-inline">
        <div style="display:flex;align-items:center;gap:8px;margin-right:8px">
            <span class="label-small">BGM</span>
            <div id="bgm-toggle" class="toggle on">ON</div>
        </div>

        <div style="display:flex;align-items:center;gap:8px;margin-right:8px">
            <span class="label-small">SFX</span>
            <div id="sfx-toggle" class="toggle on">ON</div>
        </div>

        <div style="display:flex;align-items:center;gap:6px;margin-right:6px">
            <span class="label-small">VOL</span>
            <input id="bgm-volume" class="slider" type="range" min="0" max="1" step="0.01" value="0.04">
        </div>

        <div style="display:flex;align-items:center;">
            <div id="pause-btn" class="toggle">PAUSE</div>
        </div>
    </div>
</header>

<div id="game-area">
    <canvas id="tetris"></canvas>

    <div id="next-area">
        <div style="font-size:12px;color:#bbb;margin-bottom:6px">NEXT</div>
        <canvas id="next-canvas" width="60" height="60"></canvas>
    </div>

    <div id="overlay">
        <h1 id="overlay-title">TETRIS</h1>
        <p id="overlay-msg">TAP PLAY TO START</p>
        <button id="btn-action">PLAY</button>
    </div>
</div>

<div id="footer">
    <div style="display:flex;gap:16px;align-items:center">
        <div class="btn" id="btn-left">←</div>
        <div class="btn" id="btn-right">→</div>
    </div>

    <div style="display:flex;gap:16px;align-items:center">
        <div class="btn btn-blue" id="btn-drop">⇓</div>
        <div class="btn btn-red" id="btn-rotate">↻</div>
    </div>
</div>

<script>
/* --------------------------
   GAME / RENDER SETUP (same base as before)
   -------------------------- */
const PIECES = [
    null,
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    [[2,0,0],[2,2,2],[0,0,0]],
    [[0,0,3],[3,3,3],[0,0,0]],
    [[4,4],[4,4]],
    [[0,5,5],[5,5,0],[0,0,0]],
    [[0,6,0],[6,6,6],[0,0,0]],
    [[7,7,0],[0,7,7],[0,0,0]]
];
const COLORS = [null, '#00f0f0', '#0000f0', '#f0a000', '#f0f000', '#00f000', '#a000f0', '#f00000'];

const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const nCanvas = document.getElementById('next-canvas');
const nCtx = nCanvas.getContext('2d');

const COLS = 10, ROWS = 20;
let blockSize = 20;

let board = [];
let player = { pos: {x:0,y:0}, matrix:null, score:0 };
let nextPieceType = 1;
let dropCounter = 0, dropInterval = 1000, lastTime = 0;
let isGameOver=false, isPaused=true, animationId=null;

/* --------------------------
   AUDIO: Web Audio API graph
   - masterGain controls overall BGM volume
   - bgmFilter + bgmDelay add color/reverb-like effect
   - SFX go directly through masterSfxGain
   -------------------------- */
let audioCtx = null;
let bgmInterval = null;
let bgmIndex = 0;
const BGM_MELODY = [261.63, 329.63, 392.00, 523.25, 493.88, 392.00, 440.00, 329.63];

let masterGain = null;
let masterSfxGain = null;
let bgmFilter = null;
let bgmDelay = null;

let bgmOn = true;
let sfxOn = true;

// 初期化。必ずユーザー操作（PLAY等）で呼ぶこと
function initAudioIfNeeded(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // master gain for BGM
    masterGain = audioCtx.createGain();
    masterGain.gain.setValueAtTime(parseFloat(document.getElementById('bgm-volume').value || 0.04), audioCtx.currentTime);

    // small lowpass filter for warmth
    bgmFilter = audioCtx.createBiquadFilter();
    bgmFilter.type = 'lowpass';
    bgmFilter.frequency.setValueAtTime(800, audioCtx.currentTime);

    // delay for ambiance
    bgmDelay = audioCtx.createDelay();
    bgmDelay.delayTime.setValueAtTime(0.18, audioCtx.currentTime);

    // feedback for delay
    const feedback = audioCtx.createGain();
    feedback.gain.setValueAtTime(0.18, audioCtx.currentTime);

    // connect chain: master->filter->delay->dest, with feedback loop
    masterGain.connect(bgmFilter);
    bgmFilter.connect(bgmDelay);
    bgmDelay.connect(feedback);
    feedback.connect(bgmDelay);
    bgmDelay.connect(audioCtx.destination);
    // also route a bit of filter direct to destination for clarity
    bgmFilter.connect(audioCtx.destination);

    // SFX master
    masterSfxGain = audioCtx.createGain();
    masterSfxGain.gain.setValueAtTime(0.9, audioCtx.currentTime);
    masterSfxGain.connect(audioCtx.destination);
}

// BGM play: richer sound per note (two oscillators, slight detune, envelope)
function playBgmNote(freq, dur = 0.28) {
    if (!audioCtx || !bgmOn) return;
    const now = audioCtx.currentTime;
    // oscillator A (triangle)
    const o1 = audioCtx.createOscillator();
    o1.type = 'triangle';
    o1.frequency.setValueAtTime(freq, now);

    // oscillator B (saw) with slight detune to thicken
    const o2 = audioCtx.createOscillator();
    o2.type = 'sawtooth';
    o2.frequency.setValueAtTime(freq * 0.997, now);

    // local gain
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0, now);
    g.gain.linearRampToValueAtTime(0.05, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    // connect to masterGain (so slider controls BGM) via filter/delay chain
    o1.connect(g);
    o2.connect(g);
    g.connect(masterGain);

    o1.start(now); o2.start(now);
    o1.stop(now + dur); o2.stop(now + dur);
}

function playBGM(){
    if (!audioCtx) return;
    stopBGM();
    bgmIndex = 0;
    // play one note every 350ms; notes are from BGM_MELODY
    bgmInterval = setInterval(() => {
        if (isPaused || isGameOver || !bgmOn) return;
        const freq = BGM_MELODY[bgmIndex % BGM_MELODY.length];
        playBgmNote(freq, 0.32);
        // small arpeggio layer: one additional higher note slightly delayed
        setTimeout(()=> {
            if (!audioCtx || isPaused || isGameOver || !bgmOn) return;
            playBgmNote(freq * 1.498, 0.18);
        }, 120);
        bgmIndex++;
    }, 360);
}
function stopBGM(){ if (bgmInterval) { clearInterval(bgmInterval); bgmInterval = null; } }

// SFX function (respects sfxOn)
function playSfx(type){
    if (!audioCtx || !sfxOn) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.connect(g); g.connect(masterSfxGain);
    switch(type){
        case 'move':
            osc.type='square'; osc.frequency.setValueAtTime(220, now);
            g.gain.setValueAtTime(0.04, now); g.gain.exponentialRampToValueAtTime(0.0001, now+0.08);
            osc.start(now); osc.stop(now+0.08); break;
        case 'rotate':
            osc.type='sine'; osc.frequency.setValueAtTime(420, now);
            g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
            osc.start(now); osc.stop(now+0.12); break;
        case 'drop':
            osc.type='square'; osc.frequency.setValueAtTime(110, now);
            g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
            osc.start(now); osc.stop(now+0.12); break;
        case 'clear':
            // two-tone chord
            (()=>{
                const o1 = audioCtx.createOscillator(), g1 = audioCtx.createGain();
                o1.type='square'; o1.frequency.setValueAtTime(523.25, now); g1.gain.setValueAtTime(0.09, now);
                o1.connect(g1); g1.connect(masterSfxGain);
                o1.start(now); o1.stop(now+0.22);
                const o2 = audioCtx.createOscillator(), g2 = audioCtx.createGain();
                o2.type='sine'; o2.frequency.setValueAtTime(659.25, now+0.06); g2.gain.setValueAtTime(0.07, now+0.06);
                o2.connect(g2); g2.connect(masterSfxGain); o2.start(now+0.06); o2.stop(now+0.28);
            })();
            break;
        case 'gameover':
            osc.type='sawtooth'; osc.frequency.setValueAtTime(150, now); g.gain.setValueAtTime(0.12, now);
            g.gain.linearRampToValueAtTime(0.0001, now+1.0);
            osc.start(now); osc.stop(now+1.0); break;
    }
}

/* --------------------------
   Game core (as before but safe)
   -------------------------- */
function createPiece(typeId) {
    if (!typeId) typeId = (Math.random()*7|0)+1;
    return JSON.parse(JSON.stringify(PIECES[typeId]));
}
function rotate(matrix, dir){
    for (let y=0;y<matrix.length;++y) for (let x=0;x<y;++x) [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];
    if (dir>0) matrix.forEach(row=>row.reverse()); else matrix.reverse();
}
function collide(arena, player){
    const [m,o]=[player.matrix,player.pos];
    for(let y=0;y<m.length;++y) for(let x=0;x<m[y].length;++x)
        if (m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0) return true;
    return false;
}
function merge(arena, player){
    player.matrix.forEach((row,y)=> row.forEach((v,x)=> { if (v!==0) arena[y+player.pos.y][x+player.pos.x] = v; }));
}
function arenaSweep(){
    let rowCount=0;
    outer: for (let y=board.length-1;y>0;--y){
        for (let x=0;x<board[y].length;++x) if (board[y][x]===0) continue outer;
        const row = board.splice(y,1)[0].fill(0);
        board.unshift(row); ++y; rowCount++;
    }
    if (rowCount>0){
        player.score += rowCount * 100 * rowCount;
        dropInterval = Math.max(100, 1000 - (player.score/500)*50);
        document.getElementById('score').innerText = player.score;
        document.getElementById('lines').innerText = (parseInt(document.getElementById('lines').innerText) + rowCount);
        playSfx('clear');
    }
}

function playerReset(){
    player.matrix = createPiece(nextPieceType);
    nextPieceType = (Math.random()*7|0)+1;
    drawNext();
    player.pos.y = 0;
    player.pos.x = (COLS/2|0) - (player.matrix[0].length/2|0);
    const rot = Math.random()*4|0; for(let i=0;i<rot;i++) rotate(player.matrix,1);
    if (collide(board, player)){
        isGameOver=true; isPaused=true;
        stopBGM(); playSfx('gameover');
        document.getElementById('overlay-title').innerText='GAME OVER';
        document.getElementById('overlay-msg').innerText='SCORE: ' + player.score;
        document.getElementById('btn-action').innerText='RETRY';
        document.getElementById('overlay').style.display='flex';
    }
}

function playerDrop(){
    player.pos.y++;
    if (collide(board, player)){
        player.pos.y--;
        merge(board, player);
        playSfx('drop');
        arenaSweep();
        playerReset();
        return;
    }
    dropCounter = 0;
}

function playerMove(dir){
    player.pos.x += dir;
    if (collide(board, player)) player.pos.x -= dir;
    else playSfx('move');
}

function playerRotate(dir){
    const pos = player.pos.x; let offset=1;
    rotate(player.matrix, dir);
    while (collide(board, player)){
        player.pos.x += offset;
        offset = -(offset + (offset>0?1:-1));
        if (offset > 2){ rotate(player.matrix, -dir); player.pos.x = pos; return; }
    }
    playSfx('rotate');
}

/* --------------------------
   Drawing helpers (grid on blocks)
   -------------------------- */
function drawMatrix(matrix, offset, ctxLocal){
    matrix.forEach((row,y)=>{
        row.forEach((value,x)=>{
            if (value!==0){
                ctxLocal.fillStyle = COLORS[value];
                ctxLocal.fillRect(x+offset.x, y+offset.y, 1, 1);
                // grid lines on each block (darker inner stroke)
                ctxLocal.strokeStyle = 'rgba(0,0,0,0.22)';
                ctxLocal.lineWidth = 0.04;
                ctxLocal.strokeRect(x+offset.x, y+offset.y, 1, 1);
                // highlight
                ctxLocal.fillStyle = 'rgba(255,255,255,0.06)';
                ctxLocal.fillRect(x+offset.x+0.06, y+offset.y+0.06, 0.4, 0.18);
            }
        });
    });
}

function drawGhost(){
    let ghostY = player.pos.y;
    while(!collide(board, {matrix:player.matrix, pos:{x:player.pos.x, y:ghostY+1}})) ghostY++;
    ctx.globalAlpha = 0.25;
    drawMatrix(player.matrix, {x:player.pos.x, y:ghostY}, ctx);
    ctx.globalAlpha = 1.0;
}

function draw(){
    // clear in device pixels
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    // scale by blockSize
    ctx.setTransform(blockSize,0,0,blockSize,0,0);
    drawMatrix(board, {x:0,y:0}, ctx);
    if (player.matrix) { drawGhost(); drawMatrix(player.matrix, player.pos, ctx); }
}

function drawNext(){
    nCtx.clearRect(0,0,nCanvas.width,nCanvas.height);
    const mat = PIECES[nextPieceType];
    const scale = 15;
    const offsetX = (nCanvas.width/scale - mat[0].length)/2;
    const offsetY = (nCanvas.height/scale - mat.length)/2;
    nCtx.save();
    nCtx.scale(scale, scale);
    mat.forEach((row,y)=> row.forEach((v,x)=> {
        if (v!==0){
            nCtx.fillStyle = COLORS[v];
            nCtx.fillRect(x+offsetX, y+offsetY, 1, 1);
            nCtx.strokeStyle='rgba(0,0,0,0.22)'; nCtx.lineWidth=0.06; nCtx.strokeRect(x+offsetX, y+offsetY, 1, 1);
        }
    }));
    nCtx.restore();
}

/* --------------------------
   Input & loop
   -------------------------- */
let inputState = {left:false,right:false,down:false,rotate:false};
let inputTimers = {left:0,right:0,rotate:0};

function update(time=0){
    if (isPaused) return;
    const deltaTime = time - lastTime; lastTime = time;
    dropCounter += deltaTime;
    const interval = inputState.down ? 50 : dropInterval;
    if (dropCounter > interval) playerDrop();
    const now = Date.now();
    if (inputState.left){ if (now - inputTimers.left > 120){ playerMove(-1); inputTimers.left = now; } }
    if (inputState.right){ if (now - inputTimers.right > 120){ playerMove(1); inputTimers.right = now; } }
    if (inputState.rotate){ if (now - inputTimers.rotate > 250){ playerRotate(1); inputTimers.rotate = now; } }
    draw();
    animationId = requestAnimationFrame(update);
}

/* --------------------------
   Controls wiring (touch & mouse)
   -------------------------- */
function setupControls(){
    const bindBtn = (id,key,action) => {
        const el = document.getElementById(id);
        const start = (e)=>{ e && e.preventDefault(); if (isGameOver || isPaused) return; el.classList.add('active'); inputState[key]=true; inputTimers[key]=Date.now(); if (key!=='down') action(); };
        const end = (e)=>{ e && e.preventDefault(); el.classList.remove('active'); inputState[key]=false; };
        el.addEventListener('touchstart', start, {passive:false}); el.addEventListener('mousedown', start);
        el.addEventListener('touchend', end); el.addEventListener('mouseup', end); el.addEventListener('mouseleave', end);
    };
    bindBtn('btn-left','left', ()=>playerMove(-1));
    bindBtn('btn-right','right', ()=>playerMove(1));
    bindBtn('btn-rotate','rotate', ()=>playerRotate(1));
    const btnDrop = document.getElementById('btn-drop');
    const dropStart = (e)=>{ e && e.preventDefault(); if (isGameOver || isPaused) return; btnDrop.classList.add('active'); inputState.down = true; };
    const dropEnd = (e)=>{ e && e.preventDefault(); btnDrop.classList.remove('active'); inputState.down = false; };
    btnDrop.addEventListener('touchstart', dropStart, {passive:false}); btnDrop.addEventListener('mousedown', dropStart);
    btnDrop.addEventListener('touchend', dropEnd); btnDrop.addEventListener('mouseup', dropEnd); btnDrop.addEventListener('mouseleave', dropEnd);

    // canvas tap to start when overlay visible
    canvas.addEventListener('touchstart', (e)=>{ if (isPaused) startGame(); }, {passive:false});
    canvas.addEventListener('mousedown', ()=>{ if (isPaused) startGame(); });
}

/* --------------------------
   Game lifecycle: start / pause / resume / resize
   -------------------------- */
function startGame(){
    // user gesture: init audio and start bgm if ON
    initAudioIfNeeded();
    // resume audio context (iOS)
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    if (bgmOn) playBGM();

    document.getElementById('overlay').style.display='none';
    board = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));
    player.score = 0;
    document.getElementById('score').innerText = 0;
    document.getElementById('lines').innerText = 0;
    dropInterval = 1000;
    isGameOver=false; isPaused=false;
    nextPieceType = (Math.random()*7|0)+1;
    playerReset();
    lastTime = performance.now();
    update();
}

function pauseGame(){
    if (isPaused) return;
    isPaused = true;
    cancelAnimationFrame(animationId);
    stopBGM();
    document.getElementById('overlay-title').innerText = 'PAUSED';
    document.getElementById('overlay-msg').innerText = 'TAP RESUME';
    document.getElementById('btn-action').innerText = 'RESUME';
    document.getElementById('overlay').style.display='flex';
}

function resumeGame(){
    if (!isPaused && !isGameOver) return;
    isPaused = false;
    document.getElementById('overlay').style.display='none';
    lastTime = performance.now();
    if (bgmOn) playBGM();
    update();
}

function togglePause(){
    if (isPaused && !isGameOver) { resumeGame(); return; }
    if (!isPaused) { pauseGame(); return; }
    // if gameover and overlay says RETRY, clicking PLAY will restart (handled by PLAY button)
}

/* --------------------------
   UI wiring: toggles & slider
   -------------------------- */
document.getElementById('btn-action').addEventListener('click', ()=>{
    if (isGameOver) { // retry
        document.getElementById('btn-action').innerText='PLAY';
        // continue to start new game
    }
    // if paused and overlay shows RESUME, resume
    if (isPaused && !isGameOver && document.getElementById('btn-action').innerText === 'RESUME') {
        resumeGame();
        return;
    }
    startGame();
});

document.getElementById('pause-btn').addEventListener('click', ()=>{
    if (!audioCtx) initAudioIfNeeded();
    if (!isPaused) pauseGame(); else resumeGame();
    // update visual
    document.getElementById('pause-btn').classList.toggle('on', isPaused && !isGameOver);
    document.getElementById('pause-btn').innerText = isPaused ? 'RESUME' : 'PAUSE';
});

// bgm toggle
document.getElementById('bgm-toggle').addEventListener('click', ()=>{
    bgmOn = !bgmOn;
    const el = document.getElementById('bgm-toggle');
    el.classList.toggle('on', bgmOn);
    el.innerText = bgmOn ? 'ON' : 'OFF';
    if (bgmOn){
        if (!audioCtx) initAudioIfNeeded();
        playBGM();
    } else {
        stopBGM();
    }
});

// sfx toggle
document.getElementById('sfx-toggle').addEventListener('click', ()=>{
    sfxOn = !sfxOn;
    const el = document.getElementById('sfx-toggle');
    el.classList.toggle('on', sfxOn);
    el.innerText = sfxOn ? 'ON' : 'OFF';
});

// bgm volume slider
document.getElementById('bgm-volume').addEventListener('input', (e)=>{
    const v = parseFloat(e.target.value);
    if (masterGain) masterGain.gain.setValueAtTime(v, audioCtx ? audioCtx.currentTime : 0);
});

// ensure masterGain follows initial slider value if audio already exists
// (initAudioIfNeeded will set masterGain based on slider at creation)

/* --------------------------
   resize canvas
   -------------------------- */
function resize(){
    const container = document.getElementById('game-area');
    const aspect = COLS / ROWS;
    let h = container.clientHeight;
    let w = h * aspect;
    if (w > container.clientWidth) { w = container.clientWidth; h = w / aspect; }
    w *= 0.96; h *= 0.96;
    canvas.width = Math.floor(w);
    canvas.height = Math.floor(h);
    blockSize = canvas.width / COLS;
    // don't set ctx.scale here; draw() resets transform
    if (!isPaused && !isGameOver) draw();
}
window.addEventListener('resize', resize);

/* --------------------------
   setup & start
   -------------------------- */
setupControls();
resize();
// initial overlay visible; user should press PLAY
</script>

</body>
</html>