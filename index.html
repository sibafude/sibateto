<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>スマホテトリス - WebPen版</title>
    <style>
        /* 基本スタイル設定 */
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1d;
            color: #ffffff;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100vh;
            height: 100dvh; /* Safariツールバー対策 */
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        /* スコア表示エリア */
        header {
            background-color: #2a2a2e;
            padding: 10px 0;
            display: flex;
            justify-content: space-around;
            border-bottom: 2px solid #444;
            height: 60px;
            box-sizing: border-box;
        }
        .score-box { text-align: center; }
        .label { font-size: 0.7rem; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        #score, #lines { font-size: 1.2rem; font-weight: bold; margin-top: 2px; }

        /* ゲームキャンバスエリア */
        #game-wrapper {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            background-color: #111;
        }
        canvas {
            background-color: #000;
            border: 3px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        /* ゲームオーバー表示 */
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            text-align: center;
            border-radius: 15px;
            border: 2px solid #ff4444;
            display: none;
            z-index: 100;
            width: 80%;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.3);
        }
        #game-over h2 { margin: 0 0 15px; color: #ff4444; font-size: 2rem; }
        #restart-btn {
            background: #ff4444;
            border: none;
            color: white;
            padding: 12px 25px;
            font-size: 1.1rem;
            border-radius: 30px;
            font-weight: bold;
            box-shadow: 0 4px 0 #990000;
        }
        #restart-btn:active { transform: translateY(4px); box-shadow: none; }

        /* コントローラー設定（両手操作用） */
        #controls {
            background-color: #222;
            width: 100%;
            height: 160px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 25px;
            padding-bottom: env(safe-area-inset-bottom); /* iOS セーフエリア */
            box-sizing: border-box;
            border-top: 3px solid #333;
        }

        .control-group { display: flex; gap: 20px; }

        /* ボタンのデザイン */
        .btn {
            width: 70px;
            height: 70px;
            background-color: #3d3d3d;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: white;
            box-shadow: 0 6px 0 #1a1a1a;
            transition: all 0.05s;
        }
        .btn:active, .btn.active {
            transform: translateY(6px);
            box-shadow: none;
            background-color: #555;
        }

        /* ボタンの色分け */
        .btn-drop { background-color: #007aff; box-shadow: 0 6px 0 #004a99; }
        .btn-rotate { background-color: #ff3b30; box-shadow: 0 6px 0 #991a14; }
        .btn-drop:active, .btn-drop.active { background-color: #005bb5; }
        .btn-rotate:active, .btn-rotate.active { background-color: #b52a22; }

    </style>
</head>
<body>

    <header>
        <div class="score-box">
            <div class="label">Score</div>
            <div id="score">0</div>
        </div>
        <div class="score-box">
            <div class="label">Lines</div>
            <div id="lines">0</div>
        </div>
    </header>

    <div id="game-wrapper">
        <canvas id="tetris"></canvas>
        <div id="game-over">
            <h2>GAME OVER</h2>
            <button id="restart-btn" onclick="resetGame()">RETRY</button>
        </div>
    </div>

    <!-- 左手で移動、右手で落下・回転 -->
    <div id="controls">
        <div class="control-group">
            <div class="btn" id="btn-left">←</div>
            <div class="btn" id="btn-right">→</div>
        </div>
        <div class="control-group">
            <div class="btn btn-drop" id="btn-drop">⇓</div>
            <div class="btn btn-rotate" id="btn-rotate">↻</div>
        </div>
    </div>

    <script>
        const COLS = 10;
        const ROWS = 20;
        let blockSize = 30;
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const linesEl = document.getElementById('lines');
        const gameOverEl = document.getElementById('game-over');

        let board = [];
        let score = 0;
        let lines = 0;
        let gameOver = false;
        let dropInterval = 800;
        let fastDropInterval = 50;
        let isFastDropping = false;
        let lastTime = 0;
        let dropCounter = 0;

        const SHAPES = [
            [],
            [[1, 1, 1, 1]], // I
            [[1, 1], [1, 1]], // O
            [[0, 1, 0], [1, 1, 1]], // T
            [[0, 1, 1], [1, 1, 0]], // S
            [[1, 1, 0], [0, 1, 1]], // Z
            [[1, 0, 0], [1, 1, 1]], // J
            [[0, 0, 1], [1, 1, 1]]  // L
        ];
        const COLORS = [
            'black', '#00f0f0', '#f0f000', '#a000f0', '#00f000', '#f00000', '#0000f0', '#f0a000'
        ];

        let currentPiece = { shape: [], id: 0, x: 0, y: 0 };

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupControls();
            resetGame();
            update();
        }

        function resizeCanvas() {
            const wrapper = document.getElementById('game-wrapper');
            const w = wrapper.clientWidth * 0.95;
            const h = wrapper.clientHeight * 0.95;
            const aspect = COLS / ROWS;
            let canvasW = w;
            let canvasH = canvasW / aspect;
            if (canvasH > h) {
                canvasH = h;
                canvasW = canvasH * aspect;
            }
            blockSize = canvasW / COLS;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasW * dpr;
            canvas.height = canvasH * dpr;
            canvas.style.width = canvasW + 'px';
            canvas.style.height = canvasH + 'px';
            ctx.scale(dpr, dpr);
            draw();
        }

        function resetGame() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            lines = 0;
            gameOver = false;
            dropInterval = 800;
            scoreEl.innerText = score;
            linesEl.innerText = lines;
            gameOverEl.style.display = 'none';
            spawnPiece();
        }

        function spawnPiece() {
            const id = Math.floor(Math.random() * 7) + 1;
            currentPiece.id = id;
            currentPiece.shape = SHAPES[id];
            currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentPiece.y = 0;
            if (collide()) {
                gameOver = true;
                gameOverEl.style.display = 'block';
            }
        }

        function collide() {
            const m = currentPiece.shape;
            const o = { x: currentPiece.x, y: currentPiece.y };
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0) {
                        if (!board[y + o.y] || board[y + o.y][x + o.x] !== 0) return true;
                    }
                }
            }
            return false;
        }

        function merge() {
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) board[y + currentPiece.y][x + currentPiece.x] = currentPiece.id;
                });
            });
        }

        function sweep() {
            let rowCount = 0;
            outer: for (let y = ROWS - 1; y >= 0; --y) {
                for (let x = 0; x < COLS; ++x) {
                    if (board[y][x] === 0) continue outer;
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                ++y;
                rowCount++;
            }
            if (rowCount > 0) {
                lines += rowCount;
                score += [0, 100, 300, 500, 800][rowCount];
                scoreEl.innerText = score;
                linesEl.innerText = lines;
                dropInterval = Math.max(100, 800 - (lines * 10));
            }
        }

        function rotate(matrix) {
            const rotated = matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
            const prevShape = currentPiece.shape;
            currentPiece.shape = rotated;
            if (collide()) currentPiece.shape = prevShape;
        }

        function move(dir) {
            currentPiece.x += dir;
            if (collide()) currentPiece.x -= dir;
        }

        function drop() {
            currentPiece.y++;
            if (collide()) {
                currentPiece.y--;
                merge();
                sweep();
                spawnPiece();
            }
            dropCounter = 0;
        }

        function update(time = 0) {
            if (gameOver) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            const interval = isFastDropping ? fastDropInterval : dropInterval;
            if (dropCounter > interval) drop();
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) drawBlock(x, y, COLORS[value]);
                });
            });
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) drawBlock(x + currentPiece.x, y + currentPiece.y, COLORS[currentPiece.id]);
                });
            });
            ctx.strokeStyle = '#222';
            for(let i=0; i<=COLS; i++) { ctx.beginPath(); ctx.moveTo(i*blockSize, 0); ctx.lineTo(i*blockSize, ROWS*blockSize); ctx.stroke(); }
            for(let i=0; i<=ROWS; i++) { ctx.beginPath(); ctx.moveTo(0, i*blockSize); ctx.lineTo(COLS*blockSize, i*blockSize); ctx.stroke(); }
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
        }

        function setupControls() {
            const bind = (id, start, end) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); el.classList.add('active'); start(); }, {passive:false});
                el.addEventListener('touchend', (e) => { e.preventDefault(); el.classList.remove('active'); if(end) end(); }, {passive:false});
            };
            bind('btn-left', () => move(-1));
            bind('btn-right', () => move(1));
            bind('btn-rotate', () => rotate(currentPiece.shape));
            bind('btn-drop', () => isFastDropping = true, () => isFastDropping = false);
        }

        init();
    </script>
</body>
</html>

