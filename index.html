<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tetris Perfect UI</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* ヘッダー情報 */
        header {
            background-color: #1e1e1e;
            padding: 5px 15px;
            height: 55px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-sizing: border-box;
        }
        .stat-group { display: flex; gap: 15px; width: 100%; justify-content: space-around; }
        .stat-item { text-align: center; }
        .stat-label { font-size: 0.55rem; color: #888; letter-spacing: 0.5px; margin-bottom: 2px; }
        .stat-val { font-size: 1.1rem; font-weight: bold; font-family: monospace; color: #eee; transition: color 0.3s; }
        .highlight { color: #FFD700; }

        /* ゲームエリア */
        #game-area {
            position: relative;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            overflow: hidden; 
        }
        canvas {
            background-color: rgba(20, 20, 20, 0.9);
            border: 2px solid #444;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        /* NEXT表示 */
        #next-area {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(40,40,40,0.9);
            border: 1px solid #555;
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        #next-canvas { background: transparent; }

        /* オーバーレイ */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        #overlay h1 { font-size: 2.5rem; color: #FF5252; margin: 0 0 10px 0; }
        #overlay p { color: #ccc; margin-bottom: 25px; font-size: 1.2rem; }
        #btn-action {
            padding: 12px 40px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #2196F3, #2979FF);
            color: white;
            border: none;
            border-radius: 50px;
            font-weight: bold;
            box-shadow: 0 5px 10px rgba(33, 150, 243, 0.4);
            cursor: pointer;
        }
        #btn-action:active { transform: scale(0.95); }

        /* ボーナステキストアニメーション */
        .popup-text {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.2rem;
            font-weight: 900;
            text-shadow: 0 3px 0 #000, 0 -3px 0 #000, 3px 0 0 #000, -3px 0 0 #000, 0 5px 15px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: popupAnim 2s ease-in-out forwards;
            z-index: 200;
            white-space: nowrap;
            letter-spacing: 2px;
        }
        @keyframes popupAnim {
            0% { opacity: 0; transform: translate(-50%, -10px) scale(0.5) rotate(-5deg); }
            15% { opacity: 1; transform: translate(-50%, -30px) scale(1.2) rotate(5deg); }
            30% { opacity: 1; transform: translate(-50%, -40px) scale(1) rotate(0deg); }
            80% { opacity: 1; transform: translate(-50%, -50px) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -70px) scale(0.9); }
        }

        /* --- 新レイアウト コントローラー --- */
        #controls {
            height: 120px;
            background-color: #1e1e1e;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 10px 20px calc(15px + env(safe-area-inset-bottom));
            border-top: 1px solid #333;
            box-sizing: border-box;
            position: relative; 
        }

        /* 左側（移動キー：十字配置） */
        .left-side {
            position: relative;
            width: 120px;
            height: 100px;
        }
        .d-btn {
            width: 48px;
            height: 48px;
            background: #444;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            color: #ddd;
            box-shadow: 0 4px 0 #111;
            position: absolute;
        }
        .d-btn:active, .d-btn.active { transform: translateY(4px); box-shadow: none; background: #666; }
        
        #btn-left { left: 0; bottom: 35px; }   
        #btn-right { right: 0; bottom: 35px; } 
        #btn-drop { left: 50%; bottom: 0; transform: translateX(-50%); } 

        /* 中央（状態切り替えボタン：さらに小さく） */
        .center-side {
            position: absolute;
            bottom: calc(15px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
        #btn-state {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 50%;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
            transition: transform 0.1s, background 0.2s;
            cursor: pointer;
        }
        #btn-state:active { transform: translateY(4px); box-shadow: none; }
        
        .state-icon { font-size: 1.1rem; line-height: 1; margin-bottom: 2px; }
        .state-text { font-size: 0.5rem; font-weight: bold; letter-spacing: 0px; }

        .state-start  { background: #4CAF50; box-shadow: 0 4px 0 #2E7D32 !important; } 
        .state-pause  { background: #2196F3; box-shadow: 0 4px 0 #1565C0 !important; } 
        .state-resume { background: #FF9800; box-shadow: 0 4px 0 #E65100 !important; } 
        .state-retry  { background: #F44336; box-shadow: 0 4px 0 #C62828 !important; } 

        /* 右側（回転・ハードドロップ） */
        .right-side {
            position: relative;
            width: 120px;
            height: 100px;
        }
        .a-btn {
            width: 48px; height: 48px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: #fff;
            box-shadow: 0 4px 0 rgba(0,0,0,0.8);
            position: absolute;
        }
        .a-btn:active, .a-btn.active { transform: translateY(4px); box-shadow: none; }
        
        #btn-up { top: 0px; left: 50%; transform: translateX(-50%); background: #757575; box-shadow: 0 4px 0 #424242; } 
        #btn-rot-left { bottom: 0; left: 0; background: #1976D2; box-shadow: 0 4px 0 #0D47A1; } 
        #btn-rot-right { bottom: 0; right: 0; background: #D32F2F; box-shadow: 0 4px 0 #B71C1C; } 

    </style>
</head>
<body>

    <header>
        <div class="stat-group">
            <div class="stat-item"><div class="stat-label highlight">HI-SCORE</div><div id="hi-score" class="stat-val highlight">0</div></div>
            <div class="stat-item"><div class="stat-label">SCORE</div><div id="score" class="stat-val">0</div></div>
            <div class="stat-item"><div class="stat-label">LEVEL</div><div id="level" class="stat-val">1</div></div>
            <div class="stat-item"><div class="stat-label">LINES</div><div id="lines" class="stat-val">0</div></div>
        </div>
    </header>

    <div id="game-area">
        <canvas id="tetris"></canvas>
        <div id="next-area">
            <div class="stat-label">NEXT</div>
            <canvas id="next-canvas" width="60" height="60"></canvas>
        </div>
        
        <div id="overlay">
            <h1 id="overlay-title">TETRIS</h1>
            <p id="overlay-msg">TAP TO START</p>
            <button id="btn-action">PLAY</button>
        </div>
    </div>

    <div id="controls">
        <!-- 左側：移動ボタン（十字キー風） -->
        <div class="left-side">
            <div class="d-btn" id="btn-left">⇦</div>
            <div class="d-btn" id="btn-right">⇨</div>
            <div class="d-btn" id="btn-drop">⇩</div>
        </div>

        <!-- 中央：状態ボタン（極小化） -->
        <div class="center-side">
            <div id="btn-state" class="state-start">
                <div id="state-icon" class="state-icon">▶</div>
                <div id="state-text" class="state-text">START</div>
            </div>
        </div>
        
        <!-- 右側：回転・ハードドロップ -->
        <div class="right-side">
            <div class="a-btn" id="btn-up">⇧</div>
            <div class="a-btn" id="btn-rot-left">↺</div>
            <div class="a-btn" id="btn-rot-right">↻</div>
        </div>
    </div>

    <script>
        // 画面拡大バグの防止
        document.addEventListener('touchstart', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
        let lastTouchEnd = 0;
        document.addEventListener('touchend', e => {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) e.preventDefault();
            lastTouchEnd = now;
        }, { passive: false });

        // データ定義
        const PIECES = [
            null,
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]],                         // J
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]],                         // L
            [[4, 4], [4, 4]],                                          // O
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]],                         // S
            [[0, 6, 0], [6, 6, 6], [0, 0, 0]],                         // T
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]]                          // Z
        ];
        const COLORS = [null, '#00f0f0', '#0000f0', '#f0a000', '#f0f000', '#00f000', '#a000f0', '#f00000'];

        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nCanvas = document.getElementById('next-canvas');
        const nCtx = nCanvas.getContext('2d');

        const COLS = 10, ROWS = 20;
        let board = [];
        let player = { pos: {x: 0, y: 0}, matrix: null, score: 0 };
        let nextPieceType = 1;
        
        let dropCounter = 0, dropInterval = 1000, lastTime = 0;
        let lockDelayCounter = 0; // ロックダウンディレイ用タイマー
        const LOCK_DELAY = 600;   // 自然落下後の猶予時間（0.6秒）

        let gameState = 'start'; 
        let animationId = null;
        let currentLevel = 1;
        let totalLines = 0;
        let highScore = localStorage.getItem('tetrisHighScoreUltimate') || 0;
        
        document.getElementById('hi-score').innerText = highScore;

        // オーディオ設定
        let audioCtx = null;
        let nextNoteTime = 0, noteIndex = 0;
        const melody = [659, 493, 523, 587, 523, 493, 440, 440, 523, 659, 587, 523, 493, 493, 523, 587, 659, 523, 440, 440, 587, 698, 880, 783, 698, 659, 659, 523, 659, 587, 523, 493, 493, 523, 587, 659, 523, 440, 440];
        const durations = [0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.4, 0.4, 0.4, 0.4, 0.4];
        
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            switch(type) {
                case 'move': osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); break;
                case 'rotate': osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); break;
                case 'drop': osc.type = 'square'; osc.frequency.setValueAtTime(100, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); break;
                case 'harddrop': osc.type = 'square'; osc.frequency.setValueAtTime(80, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15); osc.start(now); osc.stop(now + 0.15); break;
                case 'clear': osc.type = 'square'; osc.frequency.setValueAtTime(523, now); osc.frequency.setValueAtTime(659, now + 0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); break;
                case 'bonus': 
                    osc.type = 'sine'; osc.frequency.setValueAtTime(523, now); osc.frequency.setValueAtTime(659, now + 0.1); osc.frequency.setValueAtTime(784, now + 0.2); osc.frequency.setValueAtTime(1046, now + 0.3);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); break;
                case 'gameover': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(50, now + 1); gain.gain.setValueAtTime(0.03, now); gain.gain.linearRampToValueAtTime(0, now + 1); osc.start(now); osc.stop(now + 1); break;
            }
        }

        function scheduleBGM() {
            if (!audioCtx || gameState !== 'playing') return;
            while (nextNoteTime < audioCtx.currentTime + 0.1) {
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.type = 'square'; osc.frequency.value = melody[noteIndex % melody.length];
                gain.gain.value = 0.03; gain.gain.setValueAtTime(0.03, nextNoteTime); gain.gain.linearRampToValueAtTime(0, nextNoteTime + durations[noteIndex % melody.length] - 0.05);
                osc.start(nextNoteTime); osc.stop(nextNoteTime + durations[noteIndex % melody.length]);
                nextNoteTime += durations[noteIndex % melody.length]; noteIndex++;
            }
        }

        // --- UI演出 ---
        function showPopup(text, color) {
            const popup = document.createElement('div');
            popup.className = 'popup-text';
            popup.innerText = text;
            popup.style.color = color;
            document.getElementById('game-area').appendChild(popup);
            setTimeout(() => { if(popup.parentNode) popup.parentNode.removeChild(popup); }, 2000);
        }

        // --- ゲームロジック ---
        function createPiece(typeId) { return JSON.parse(JSON.stringify(PIECES[typeId])); }
        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) for (let x = 0; x < y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
        }

        function checkHighScore() {
            if (player.score > highScore) {
                highScore = player.score;
                document.getElementById('hi-score').innerText = highScore;
                localStorage.setItem('tetrisHighScoreUltimate', highScore);
            }
        }

        function playerReset() {
            player.matrix = createPiece(nextPieceType);
            nextPieceType = (Math.random() * 7 | 0) + 1;
            drawNext();
            player.pos.y = 0; player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0);
            for(let i=0; i<(Math.random() * 4 | 0); i++) rotate(player.matrix, 1);

            if (collide(board, player)) {
                checkHighScore();
                changeState('gameover');
            }
        }

        function collide(arena, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => { if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value; });
            });
        }

        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = board.length - 1; y > 0; --y) {
                for (let x = 0; x < board[y].length; ++x) if (board[y][x] === 0) continue outer;
                const row = board.splice(y, 1)[0].fill(0); board.unshift(row); ++y; rowCount++;
            }
            
            if (rowCount > 0) {
                let baseScore = rowCount * rowCount * 100 * currentLevel;
                let bonusText = "";
                let bonusColor = "";

                if (rowCount === 4) {
                    baseScore += 2000 * currentLevel;
                    bonusText = "テトリス！";
                    bonusColor = "#00E5FF"; 
                }

                let isPerfectClear = true;
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x] !== 0) {
                            isPerfectClear = false; break;
                        }
                    }
                    if (!isPerfectClear) break;
                }

                if (isPerfectClear) {
                    baseScore += 5000 * currentLevel;
                    bonusText = bonusText ? "全消し＆テトリス！" : "全消し！";
                    bonusColor = "#FFEA00"; 
                }

                player.score += baseScore;
                totalLines += rowCount;
                
                currentLevel = Math.floor(totalLines / 10) + 1;
                
                // 落下速度の計算：レベルが上がると急激に速くなり、レベル10で少しゆっくりに戻って再加速する
                if (currentLevel < 10) {
                    // レベル1〜9：0.70乗で急激に加速 (1: 1000ms, 2: 700ms, 3: 490ms ...)
                    dropInterval = Math.max(60, 1000 * Math.pow(0.70, currentLevel - 1));
                } else {
                    // レベル10以降：基準を800ms(最初より少し速い)にリセットし、再び加速
                    let resetLevel = currentLevel - 9;
                    dropInterval = Math.max(60, 800 * Math.pow(0.70, resetLevel - 1));
                }
                
                document.getElementById('score').innerText = player.score;
                document.getElementById('lines').innerText = totalLines;
                document.getElementById('level').innerText = currentLevel;
                
                checkHighScore();
                
                if (bonusText) {
                    playSound('bonus');
                    showPopup(bonusText, bonusColor);
                } else {
                    playSound('clear');
                }
            }
        }

        // ロックダウン（固定）処理
        function lockPiece() {
            merge(board, player);
            playSound('drop');
            arenaSweep();
            playerReset();
            lockDelayCounter = 0;
            dropCounter = 0;
        }

        function playerHardDrop() {
            while (!collide(board, player)) player.pos.y++;
            player.pos.y--; 
            playSound('harddrop');
            lockPiece(); // ハードドロップ時は即固定
        }

        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(board, player)) {
                player.pos.x -= dir;
            } else {
                playSound('move');
                lockDelayCounter = 0; // 移動成功時は固定猶予をリセット
            }
        }

        function playerRotate(dir) {
            const pos = player.pos.x; let offset = 1; rotate(player.matrix, dir);
            while (collide(board, player)) {
                player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > 2) { rotate(player.matrix, -dir); player.pos.x = pos; return; }
            }
            playSound('rotate');
            lockDelayCounter = 0; // 回転成功時は固定猶予をリセット
        }

        // --- 描画関連 ---
        function drawGrid() {
            ctx.lineWidth = 0.03; // 線を少ししっかりさせる
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)'; // 透明度を上げて濃く表示
            // 縦線
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, ROWS); ctx.stroke();
            }
            // 横線
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(COLS, y); ctx.stroke();
            }
        }

        function drawMatrix(matrix, offset, ctx) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = COLORS[value]; ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                        ctx.lineWidth = 0.05; ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(x + offset.x + 0.1, y + offset.y + 0.8, 0.8, 0.1); ctx.fillRect(x + offset.x + 0.8, y + offset.y + 0.1, 0.1, 0.8);
                    }
                });
            });
        }
        function drawGhost() {
            let ghostY = player.pos.y;
            while(!collide(board, {matrix: player.matrix, pos: {x: player.pos.x, y: ghostY + 1}})) ghostY++;
            ctx.globalAlpha = 0.2; // 0.4から0.2に変更してより薄くする
            drawMatrix(player.matrix, {x: player.pos.x, y: ghostY}, ctx); 
            ctx.globalAlpha = 1.0;
        }
        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height); // 背景を黒に塗りつぶす
            drawGrid(); // マス目を描画
            drawMatrix(board, {x: 0, y: 0}, ctx); // 積まれたブロックを描画
            drawGhost(); // ゴーストを描画
            drawMatrix(player.matrix, player.pos, ctx); // 操作中のブロックを描画
        }
        function drawNext() {
            nCtx.clearRect(0, 0, nCanvas.width, nCanvas.height);
            const nextMatrix = PIECES[nextPieceType]; const scale = 15;
            const offsetX = (nCanvas.width / scale - nextMatrix[0].length) / 2; const offsetY = (nCanvas.height / scale - nextMatrix.length) / 2;
            nCtx.save(); nCtx.scale(scale, scale);
            nextMatrix.forEach((row, y) => { row.forEach((value, x) => {
                if (value !== 0) {
                    nCtx.fillStyle = COLORS[value]; nCtx.fillRect(x + offsetX, y + offsetY, 1, 1);
                    nCtx.lineWidth = 0.1; nCtx.strokeStyle = 'white'; nCtx.strokeRect(x + offsetX, y + offsetY, 1, 1);
                }
            });});
            nCtx.restore();
        }

        // --- ループと入力 ---
        const inputState = { left: false, right: false, down: false, rotLeft: false, rotRight: false };
        const inputTimers = { left: 0, right: 0, rotLeft: 0, rotRight: 0 };

        function update(time = 0) {
            if (gameState !== 'playing') return;
            const deltaTime = time - lastTime; lastTime = time;
            scheduleBGM();

            // 連続入力処理 (移動：120ms間隔、回転：250ms間隔)
            const now = Date.now();
            if (inputState.left && now - inputTimers.left > 120) { playerMove(-1); inputTimers.left = now; }
            if (inputState.right && now - inputTimers.right > 120) { playerMove(1); inputTimers.right = now; }
            if (inputState.rotLeft && now - inputTimers.rotLeft > 250) { playerRotate(-1); inputTimers.rotLeft = now; }
            if (inputState.rotRight && now - inputTimers.rotRight > 250) { playerRotate(1); inputTimers.rotRight = now; }

            // 落下・接地判定
            player.pos.y++;
            const isGrounded = collide(board, player);
            player.pos.y--;

            if (isGrounded) {
                // 下にブロックがある（接地中）
                lockDelayCounter += deltaTime;
                // 下キー長押し時は即座(50ms)に固定、自然落下の時は0.6秒待って固定
                if (lockDelayCounter >= LOCK_DELAY || (inputState.down && lockDelayCounter >= 50)) {
                    lockPiece();
                }
            } else {
                // 空中（落下中）
                lockDelayCounter = 0;
                dropCounter += deltaTime;
                const interval = inputState.down ? 50 : dropInterval;
                if (dropCounter > interval) {
                    player.pos.y++;
                    dropCounter = 0;
                }
            }

            draw();
            animationId = requestAnimationFrame(update);
        }

        function setupControls() {
            const bindBtn = (id, key, action, isContinuous) => {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); if (gameState !== 'playing') return;
                    btn.classList.add('active');
                    if (isContinuous && key) { inputState[key] = true; inputTimers[key] = Date.now(); }
                    if (action) action(); // 押した瞬間に1回実行
                }, {passive: false});
                const endHandler = (e) => {
                    e.preventDefault(); btn.classList.remove('active');
                    if (isContinuous && key) inputState[key] = false;
                };
                btn.addEventListener('touchend', endHandler); btn.addEventListener('mouseleave', endHandler);
            };

            // 移動 (連続入力ON)
            bindBtn('btn-left', 'left', () => playerMove(-1), true);
            bindBtn('btn-right', 'right', () => playerMove(1), true);
            bindBtn('btn-drop', 'down', null, true);
            
            // ハードドロップ (連続入力OFF)
            bindBtn('btn-up', null, () => playerHardDrop(), false);
            
            // 回転 (連続入力ONに対応)
            bindBtn('btn-rot-left', 'rotLeft', () => playerRotate(-1), true);
            bindBtn('btn-rot-right', 'rotRight', () => playerRotate(1), true);
        }

        // --- 状態管理 ---
        function changeState(newState) {
            gameState = newState;
            const stateBtn = document.getElementById('btn-state');
            const sIcon = document.getElementById('state-icon');
            const sText = document.getElementById('state-text');
            const overlay = document.getElementById('overlay');
            const oTitle = document.getElementById('overlay-title');
            const oMsg = document.getElementById('overlay-msg');
            const oBtn = document.getElementById('btn-action');

            if (newState === 'start') {
                stateBtn.className = 'state-start'; sIcon.innerText = '▶'; sText.innerText = 'START';
                sIcon.style.marginLeft = '2px';
                overlay.style.display = 'flex'; oTitle.innerText = 'TETRIS'; oTitle.style.color = '#FF5252'; oMsg.innerText = 'TAP TO START'; oBtn.innerText = 'PLAY';
            } else if (newState === 'playing') {
                stateBtn.className = 'state-pause'; sIcon.innerText = '⏸'; sText.innerText = 'PAUSE';
                sIcon.style.marginLeft = '0px';
                overlay.style.display = 'none';
                lastTime = performance.now();
                update();
            } else if (newState === 'paused') {
                stateBtn.className = 'state-resume'; sIcon.innerText = '▶'; sText.innerText = 'RESUME';
                sIcon.style.marginLeft = '2px';
                overlay.style.display = 'flex'; oTitle.innerText = 'PAUSE'; oTitle.style.color = '#2196F3'; oMsg.innerText = 'Game is Paused'; oBtn.innerText = 'RESUME';
            } else if (newState === 'gameover') {
                stateBtn.className = 'state-retry'; sIcon.innerText = '↺'; sText.innerText = 'RETRY';
                sIcon.style.marginLeft = '0px';
                playSound('gameover');
                overlay.style.display = 'flex'; oTitle.innerText = 'GAME OVER'; oTitle.style.color = '#FF5252'; oMsg.innerText = 'SCORE: ' + player.score; oBtn.innerText = 'RETRY';
            }
        }

        function handleStateAction() {
            initAudio();
            if (gameState === 'start' || gameState === 'gameover') {
                board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
                player.score = 0; currentLevel = 1; totalLines = 0; dropInterval = 1000; lockDelayCounter = 0;
                document.getElementById('score').innerText = 0; document.getElementById('lines').innerText = 0; document.getElementById('level').innerText = 1;
                
                document.querySelectorAll('.popup-text').forEach(e => e.remove());
                
                if (audioCtx) { nextNoteTime = audioCtx.currentTime; noteIndex = 0; }
                nextPieceType = (Math.random() * 7 | 0) + 1;
                playerReset();
                changeState('playing');
            } else if (gameState === 'playing') {
                changeState('paused');
            } else if (gameState === 'paused') {
                if (audioCtx) nextNoteTime = audioCtx.currentTime; 
                changeState('playing');
            }
        }

        document.getElementById('btn-state').addEventListener('touchstart', (e) => { e.preventDefault(); handleStateAction(); }, {passive: false});
        document.getElementById('btn-action').addEventListener('click', handleStateAction);

        function resize() {
            const container = document.getElementById('game-area');
            const aspect = COLS / ROWS;
            let h = container.clientHeight; let w = h * aspect;
            if (w > container.clientWidth) { w = container.clientWidth; h = w / aspect; }
            w *= 0.96; h *= 0.96; 
            canvas.width = w; canvas.height = h;
            ctx.scale(w / COLS, w / COLS);
            if(gameState === 'playing') draw();
            else if (gameState === 'start') { draw(); drawNext(); } 
        }

        window.addEventListener('resize', resize);
        setupControls(); 
        changeState('start');
        resize();

    </script>
</body>
</html>


