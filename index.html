<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>スマホテトリス</title>
    <style>
        /* --- 基本設定 --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #202028;
            color: #fff;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100vh;
            /* iOS Safari対策: アドレスバー分を考慮した高さ */
            height: 100dvh; 
            overflow: hidden;
            touch-action: none; /* 画面全体のズーム・スクロール防止 */
            user-select: none; /* テキスト選択防止 */
            -webkit-user-select: none;
        }

        /* --- ヘッダー --- */
        header {
            background-color: #333;
            padding: 8px 0;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            z-index: 10;
            height: 50px;
            box-sizing: border-box;
        }
        .score-box { text-align: center; }
        .label { font-size: 0.6rem; color: #aaa; margin-bottom: 2px;}
        #score, #lines { font-size: 1.1rem; font-weight: bold; line-height: 1;}

        /* --- ゲーム画面エリア --- */
        #game-wrapper {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            overflow: hidden;
            background-color: #111;
        }

        canvas {
            background-color: #000;
            border: 2px solid #555;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            display: block;
        }

        /* ゲームオーバー表示 */
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            text-align: center;
            border-radius: 10px;
            border: 2px solid #fff;
            display: none;
            z-index: 20;
            width: 70%;
        }
        #game-over h2 { margin: 0 0 20px; color: #ff5555; }
        #restart-btn {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
        }

        /* --- コントローラー --- */
        #controls {
            background-color: #2a2a35;
            width: 100%;
            height: 140px; /* 固定高さ */
            
            /* Safariの下部メニューバー対策 */
            padding-bottom: env(safe-area-inset-bottom);
            
            display: flex;
            justify-content: space-between; /* 左右に分割 */
            align-items: center;
            padding-left: 20px;
            padding-right: 20px;
            box-sizing: border-box;
            border-top: 2px solid #444;
        }

        /* 左手エリア・右手エリア */
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        /* ボタンデザイン */
        .btn {
            width: 65px;
            height: 65px;
            background-color: #444;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            box-shadow: 0 6px 0 #222;
            transition: transform 0.05s, box-shadow 0.05s, background-color 0.1s;
            color: #fff;
            /* タッチの反応を良くする */
            touch-action: manipulation; 
        }

        .btn:active, .btn.active {
            transform: translateY(6px);
            box-shadow: none;
            background-color: #666;
        }

        /* 色分け */
        .btn-left, .btn-right { background-color: #424242; } /* グレー */
        .btn-drop { background-color: #1976D2; box-shadow: 0 6px 0 #0D47A1; } /* 青 */
        .btn-rotate { background-color: #d32f2f; box-shadow: 0 6px 0 #8e0000; } /* 赤 */

        .btn-drop:active, .btn-drop.active { background-color: #2196F3; }
        .btn-rotate:active, .btn-rotate.active { background-color: #f44336; }

    </style>
</head>
<body>

    <header>
        <div class="score-box">
            <div class="label">SCORE</div>
            <div id="score">0</div>
        </div>
        <div class="score-box">
            <div class="label">LINES</div>
            <div id="lines">0</div>
        </div>
    </header>

    <div id="game-wrapper">
        <canvas id="tetris"></canvas>
        <div id="game-over">
            <h2>GAME OVER</h2>
            <button id="restart-btn" onclick="resetGame()">RETRY</button>
        </div>
    </div>

    <div id="controls">
        <!-- 左手: 移動 -->
        <div class="control-group">
            <div class="btn btn-left" id="btn-left">←</div>
            <div class="btn btn-right" id="btn-right">→</div>
        </div>

        <!-- 右手: 落下・回転 -->
        <div class="control-group">
            <div class="btn btn-drop" id="btn-drop">⇓</div>
            <div class="btn btn-rotate" id="btn-rotate">↻</div>
        </div>
    </div>

    <script>
        // --- 設定 ---
        const COLS = 10;
        const ROWS = 20;
        let blockSize = 30; 
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const linesEl = document.getElementById('lines');
        const gameOverEl = document.getElementById('game-over');

        // --- ゲーム状態変数 ---
        let board = [];
        let score = 0;
        let lines = 0;
        let gameOver = false;
        
        // --- テトロミノ定義 ---
        const SHAPES = [
            [], 
            [[1, 1, 1, 1]],             // I
            [[1, 1], [1, 1]],           // O
            [[0, 1, 0], [1, 1, 1]],     // T
            [[0, 1, 1], [1, 1, 0]],     // S
            [[1, 1, 0], [0, 1, 1]],     // Z
            [[1, 0, 0], [1, 1, 1]],     // J
            [[0, 0, 1], [1, 1, 1]]      // L
        ];
        const COLORS = [
            'black', '#00f0f0', '#f0f000', '#a000f0', '#00f000', '#f00000', '#0000f0', '#f0a000'
        ];

        let currentPiece = { shape: [], id: 0, x: 0, y: 0 };

        // --- ゲームループ制御 ---
        let dropInterval = 1000; // 通常の落下速度
        let fastDropInterval = 50; // 高速落下の速度
        let isFastDropping = false; // 高速落下中フラグ

        let lastTime = 0;
        let dropCounter = 0;

        // --- 初期化 ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupControls();
            resetGame();
            update();
        }

        // --- リサイズ処理 ---
        function resizeCanvas() {
            const wrapper = document.getElementById('game-wrapper');
            const style = getComputedStyle(wrapper);
            const w = wrapper.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
            const h = wrapper.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);

            const aspect = COLS / ROWS;
            let newW = w;
            let newH = newW / aspect;

            if (newH > h) {
                newH = h;
                newW = newH * aspect;
            }

            // 少しマージンを持たせる
            newW *= 0.96;
            newH *= 0.96;

            blockSize = newW / COLS;

            const dpr = window.devicePixelRatio || 1;
            canvas.width = newW * dpr;
            canvas.height = newH * dpr;
            canvas.style.width = newW + 'px';
            canvas.style.height = newH + 'px';
            ctx.scale(dpr, dpr);
            
            if(!gameOver) draw();
        }

        // --- ゲームロジック ---
        function resetGame() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            lines = 0;
            gameOver = false;
            dropInterval = 1000;
            isFastDropping = false;
            scoreEl.innerText = score;
            linesEl.innerText = lines;
            gameOverEl.style.display = 'none';
            spawnPiece();
        }

        function spawnPiece() {
            const id = Math.floor(Math.random() * 7) + 1;
            const shape = SHAPES[id];
            currentPiece.id = id;
            currentPiece.shape = shape;
            currentPiece.x = Math.floor(COLS / 2) - Math.floor(shape[0].length / 2);
            currentPiece.y = 0;

            if (collide(board, currentPiece)) {
                gameOver = true;
                gameOverEl.style.display = 'block';
            }
        }

        function collide(board, piece) {
            const m = piece.shape;
            const o = { x: piece.x, y: piece.y };
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0) {
                        if (!board[y + o.y] || board[y + o.y][x + o.x] === undefined || board[y + o.y][x + o.x] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function merge(board, piece) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        board[y + piece.y][x + piece.x] = piece.id;
                    }
                });
            });
        }

        function sweep() {
            let rowCount = 0;
            outer: for (let y = ROWS - 1; y > 0; --y) {
                for (let x = 0; x < COLS; ++x) {
                    if (board[y][x] === 0) continue outer;
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                ++y;
                rowCount++;
            }
            if (rowCount > 0) {
                lines += rowCount;
                score += rowCount * 100 * rowCount;
                scoreEl.innerText = score;
                linesEl.innerText = lines;
                // レベルアップ（速度上昇）
                dropInterval = Math.max(100, 1000 - (lines * 20)); 
            }
        }

        function rotate(matrix) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            matrix.forEach(row => row.reverse());
        }

        function playerMove(dir) {
            currentPiece.x += dir;
            if (collide(board, currentPiece)) {
                currentPiece.x -= dir;
            }
        }

        function playerDrop() {
            currentPiece.y++;
            if (collide(board, currentPiece)) {
                currentPiece.y--;
                merge(board, currentPiece);
                spawnPiece();
                sweep();
                return true; // 固定された
            }
            return false; // まだ落下中
        }

        function playerRotate() {
            const pos = currentPiece.x;
            let offset = 1;
            rotate(currentPiece.shape);
            while (collide(board, currentPiece)) {
                currentPiece.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > currentPiece.shape[0].length) {
                    rotate(currentPiece.shape);
                    rotate(currentPiece.shape);
                    rotate(currentPiece.shape);
                    currentPiece.x = pos;
                    return;
                }
            }
        }

        // --- ループ処理 ---
        function update(time = 0) {
            if (gameOver) {
                draw();
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            // 落下判定：高速落下中は間隔を短くする
            const currentInterval = isFastDropping ? fastDropInterval : dropInterval;

            if (dropCounter > currentInterval) {
                playerDrop();
                dropCounter = 0;
            }

            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) drawBlock(x, y, COLORS[value]);
                });
            });

            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) drawBlock(x + currentPiece.x, y + currentPiece.y, COLORS[currentPiece.id]);
                });
            });

            // グリッド線
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for(let r=0; r<=ROWS; r++){
                 ctx.beginPath(); ctx.moveTo(0, r*blockSize); ctx.lineTo(COLS*blockSize, r*blockSize); ctx.stroke();
            }
            for(let c=0; c<=COLS; c++){
                 ctx.beginPath(); ctx.moveTo(c*blockSize, 0); ctx.lineTo(c*blockSize, ROWS*blockSize); ctx.stroke();
            }
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
        }

        // --- コントローラー設定（重要） ---
        function setupControls() {
            // ヘルパー関数: イベントリスナーを簡単に追加
            const addTouch = (id, startFn, endFn) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // デフォルト動作（スクロール等）を無効化
                    el.classList.add('active'); // CSSでボタンを凹ませる
                    startFn(e);
                }, { passive: false });

                const endHandler = (e) => {
                    e.preventDefault();
                    el.classList.remove('active');
                    if (endFn) endFn(e);
                };

                el.addEventListener('touchend', endHandler, { passive: false });
                el.addEventListener('touchcancel', endHandler, { passive: false });
                el.addEventListener('mouseleave', endHandler, { passive: false }); // PC用
            };

            // 左移動
            addTouch('btn-left', () => playerMove(-1));
            // 右移動
            addTouch('btn-right', () => playerMove(1));
            // 回転
            addTouch('btn-rotate', () => playerRotate());

            // 落下ボタン（長押し対応）
            addTouch('btn-drop', 
                () => { isFastDropping = true; },  // Touch Start
                () => { isFastDropping = false; }  // Touch End
            );

            // PCキーボード操作（デバッグ用）
            document.addEventListener('keydown', event => {
                if (event.keyCode === 37) playerMove(-1);
                else if (event.keyCode === 39) playerMove(1);
                else if (event.keyCode === 38) playerRotate();
                else if (event.keyCode === 40) isFastDropping = true;
            });
            document.addEventListener('keyup', event => {
                 if (event.keyCode === 40) isFastDropping = false;
            });
        }

        init();
    </script>
</body>
</html>


